// File: sdram_test.v
// Generated by MyHDL 1.0dev
// Date: Sat Jul 21 15:19:26 2018


`timescale 1ns/10ps
`ifndef	VERILATOR
`define OPT_STANDALONE
`endif
module sdram_test (
    inp_clk,
    sdram_clk_o,
    sdram_clk_i,
    led_disp_d0_o,
    led_disp_d1_o,
    led_disp_d2_o,
    led_disp_d3_o,
    led_disp_d4_o,
    led_disp_d5_o,
    led_disp_d6_o,
    led_disp_d7_o,
    led_status,
    pb_i,
    sdramCntl_inst_sd_intf_cke,
    sdramCntl_inst_sd_intf_we,
    sdramCntl_inst_sd_intf_addr,
    sdramCntl_inst_sd_intf_dqml,
    sdramCntl_inst_sd_intf_cas,
    sdramCntl_inst_sd_intf_dqmh,
    sdramCntl_inst_sd_intf_ras,
    sdramCntl_inst_sd_intf_bs,
    sdramCntl_inst_sd_intf_cs,
    sdramCntl_inst_sd_intf_dq,
    o_uart_tx
);
input inp_clk;
output sdram_clk_o;
wire sdram_clk_o;
input sdram_clk_i;
output led_disp_d0_o;
wire led_disp_d0_o;
output led_disp_d1_o;
wire led_disp_d1_o;
output led_disp_d2_o;
wire led_disp_d2_o;
output led_disp_d3_o;
wire led_disp_d3_o;
output led_disp_d4_o;
wire led_disp_d4_o;
output led_disp_d5_o;
wire led_disp_d5_o;
output led_disp_d6_o;
wire led_disp_d6_o;
output led_disp_d7_o;
wire led_disp_d7_o;
output [3:0] led_status;
reg [3:0] led_status;
input pb_i;
output sdramCntl_inst_sd_intf_cke;
reg sdramCntl_inst_sd_intf_cke;
output sdramCntl_inst_sd_intf_we;
reg sdramCntl_inst_sd_intf_we;
output [12:0] sdramCntl_inst_sd_intf_addr;
reg [12:0] sdramCntl_inst_sd_intf_addr;
output sdramCntl_inst_sd_intf_dqml;
reg sdramCntl_inst_sd_intf_dqml;
output sdramCntl_inst_sd_intf_cas;
reg sdramCntl_inst_sd_intf_cas;
output sdramCntl_inst_sd_intf_dqmh;
reg sdramCntl_inst_sd_intf_dqmh;
output sdramCntl_inst_sd_intf_ras;
reg sdramCntl_inst_sd_intf_ras;
output [1:0] sdramCntl_inst_sd_intf_bs;
reg [1:0] sdramCntl_inst_sd_intf_bs;
output sdramCntl_inst_sd_intf_cs;
reg sdramCntl_inst_sd_intf_cs;
inout [15:0] sdramCntl_inst_sd_intf_dq;
wire [15:0] sdramCntl_inst_sd_intf_dq;
output	wire	o_uart_tx;
reg pb_prev;
reg pb_debounced;
reg initialized;
reg [5:0] debounce_cntr;
wire clk;
wire reset;
reg [7:0] test_status;
reg [7:0] led_disp_inst_digit_shf;
reg led_disp_inst_initialized;
reg [9:0] led_disp_inst_seg_timer;
reg led_disp_inst_blank;
wire [6:0] led_disp_inst_active_segments;
reg [7:0] led_disp_inst_drvr_enbls;
reg [2:0] led_disp_inst_seg_cntr;
reg [6:0] led_disp_inst_seg_mask;
wire [55:0] led_disp_inst_digit_all_i;
reg [6:0] led_disp_inst_segments;
reg [6:0] led_disp_inst_active_digit;
reg [2:0] sdramCntl_inst_cmd_r;
reg [12:0] sdramCntl_inst_sAddr_x;
reg [2:0] sdramCntl_inst_cmd_x;
wire [12:0] sdramCntl_inst_row_s;
reg [12:0] sdramCntl_inst_sAddr_r;
reg [15:0] sdramCntl_inst_sdramData_x;
reg sdramCntl_inst_activateInProgress_s;
wire sdramCntl_inst_host_intf_done_o;
reg sdramCntl_inst_sDataDir_x;
reg sdramCntl_inst_sDataDir_r;
wire [1:0] sdramCntl_inst_ba_x;
reg [4:0] sdramCntl_inst_rdPipeline_r;
reg [13:0] sdramCntl_inst_rfshCntr_x;
reg [1:0] sdramCntl_inst_ba_r;
reg [4:0] sdramCntl_inst_rdPipeline_x;
wire [15:0] sdramCntl_inst_host_intf_data_o;
reg [13:0] sdramCntl_inst_rfshCntr_r;
reg [15:0] sdramCntl_inst_sDriver;
reg [1:0] sdramCntl_inst_activeBank_x;
wire sdramCntl_inst_host_intf_wr_i;
reg sdramCntl_inst_doActivate_s;
wire [15:0] sdramCntl_inst_host_intf_data_i;
wire [1:0] sdramCntl_inst_bank_s;
reg [9:0] sdramCntl_inst_refTimer_r;
reg sdramCntl_inst_rdInProgress_s;
reg [9:0] sdramCntl_inst_refTimer_x;
reg sdramCntl_inst_writeInProgress_s;
reg [2:0] sdramCntl_inst_state_x;
reg [15:0] sdramCntl_inst_sData_r;
wire [8:0] sdramCntl_inst_col_s;
reg [2:0] sdramCntl_inst_state_r;
wire [15:0] sdramCntl_inst_sData_x;
reg [10:0] sdramCntl_inst_timer_x;
reg [4:0] sdramCntl_inst_wrPipeline_x;
reg [1:0] sdramCntl_inst_activeBank_r;
reg [1:0] sdramCntl_inst_wrTimer_x;
wire sdramCntl_inst_host_intf_rdPending_o;
wire [23:0] sdramCntl_inst_host_intf_addr_i;
reg [4:0] sdramCntl_inst_wrPipeline_r;
reg [15:0] sdramCntl_inst_sdramData_r;
reg [1:0] sdramCntl_inst_wrTimer_r;
reg [10:0] sdramCntl_inst_timer_r;
wire sdramCntl_inst_host_intf_rd_i;
reg [2:0] sdramCntl_inst_rasTimer_x;
reg [2:0] sdramCntl_inst_rasTimer_r;
reg memory_test_inst_rand_load;
wire [15:0] memory_test_inst_rand_val;
reg memory_test_inst_rd_enable;
reg [1:0] memory_test_inst_test_state;
reg memory_test_inst_rand_enable;
reg [26:0] memory_test_inst_address;
wire memory_test_inst_host_intf_rst_i;
reg memory_test_inst_wr_enable;
reg memory_test_inst_error;
reg [15:0] memory_test_inst_rand_gen_shfreg;
wire led_disp_drvrs [0:8-1];
reg [12:0] sdramCntl_inst_activeRow_x [0:4-1];
reg [12:0] sdramCntl_inst_activeRow_r [0:4-1];
reg sdramCntl_inst_activeFlag_x [0:4-1];
reg sdramCntl_inst_activeFlag_r [0:4-1];

assign led_disp_inst_digit_all_i = 56'd0;
assign d7 = led_disp_d7_o;
assign d6 = led_disp_d6_o;
assign d5 = led_disp_d5_o;
assign d2 = led_disp_d2_o;
assign d4 = led_disp_d4_o;
assign d0 = led_disp_d0_o;
assign d1 = led_disp_d1_o;
assign d3 = led_disp_d3_o;
assign led_disp_drvrs[7] = led_disp_inst_inst_8_o_drvr;
assign led_disp_drvrs[2] = led_disp_inst_inst_3_o_drvr;
assign led_disp_drvrs[0] = led_disp_inst_inst_1_o_drvr;
assign led_disp_drvrs[3] = led_disp_inst_inst_4_o_drvr;
assign led_disp_drvrs[4] = led_disp_inst_inst_5_o_drvr;
assign led_disp_drvrs[1] = led_disp_inst_inst_2_o_drvr;
assign led_disp_drvrs[5] = led_disp_inst_inst_6_o_drvr;
assign led_disp_drvrs[6] = led_disp_inst_inst_7_o_drvr;
assign sdramCntl_inst_sd_intf_dq = sdramCntl_inst_sDriver;



assign reset = ((!initialized) || (!pb_debounced));

	wire	clk_50mhz, pll_locked;
	SB_PLL40_CORE #(
		.FEEDBACK_PATH("SIMPLE"),
		.DELAY_ADJUSTMENT_MODE_FEEDBACK("FIXED"),
		.DELAY_ADJUSTMENT_MODE_RELATIVE("FIXED"),
		.PLLOUT_SELECT("GENCLK"),
		.FDA_FEEDBACK(4'b1111),
		.FDA_RELATIVE(4'b1111),
		.DIVR(4'b0000),		// Divide by (DIVR+1)
		.DIVQ(3'b100),		// Divide by 2^(DIVQ)
		.DIVF(7'b0000111),		// Multiply by (DIVF+1)
		.FILTER_RANGE(3'b001)
	) plli (
		.REFERENCECLK    (inp_clk        ),
		.PLLOUTCORE     (clk_50mhz    ),
		.LOCK           (pll_locked  ),
		.BYPASS         (1'b0         ),
		.RESETB         (1'b1         )
	); 
	assign master_clk_i = clk_50mhz;


assign sdram_clk_o = master_clk_i;
assign clk = sdram_clk_i;

parameter	INITIAL_UART_SETUP = 31'd217;
 
`ifdef	OPT_STANDALONE
	wire	[30:0]	i_setup;
	assign	i_setup = INITIAL_UART_SETUP;
`else
	input	[30:0]	i_setup;
`endif
	reg	pwr_reset;
	initial	pwr_reset = 1'b1;
	always @(posedge master_clk_i)
		pwr_reset <= 1'b0;

reg	[7:0]	message	[0:26];
	
	initial begin
		message[ 0] = "t";
		message[ 1] = "e";
		message[ 2] = "s";
		message[ 3] = "t";
		message[ 4] = " ";
		message[ 5] = " ";
		message[ 6] = " ";
		message[ 7] = "a";
		message[ 8] = "d";
		message[ 9] = "d";
		message[10] = " ";
		message[11] = " ";
		message[12] = " ";
		message[13] = " ";
		message[14] = " ";
		message[15] = "d";
		message[16] = "a";
		message[17] = "t";
		message[18] = "a";
		message[19] = " ";
		message[20] = " ";
		message[21] = " ";
		message[22] = " ";
		message[23] = " ";	
		message[24] = "!";	
		message[25] = "\r";
		message[26] = "\n";
	end
	reg	[27:0]	counter;
	initial	counter = 28'hffffff0;
	always @(posedge master_clk_i)
		counter <= counter + 1'b1;

	wire		tx_break, tx_busy;
	reg		tx_stb;
	reg	[4:0]	tx_index;
	reg	[7:0]	tx_data;

	assign	tx_break = 1'b0;

	initial	tx_index = 4'h0;
	always @(posedge master_clk_i)
		if ((tx_stb)&&(!tx_busy))
			tx_index <= tx_index + 1'b1;
	always @(posedge master_clk_i)
		tx_data <= message[tx_index];

	initial	tx_stb = 1'b0;
	always @(posedge master_clk_i)
		if (&counter)
			tx_stb <= 1'b1;
		else if ((tx_stb)&&(!tx_busy)&&(tx_index==5'h1A))
			tx_stb <= 1'b0;
 
	// Bypass any hardware flow control
	wire	cts_n;
	assign	cts_n = 1'b0;
	
	txuart	transmitter(master_clk_i, pwr_reset, i_setup, tx_break,
		tx_stb, tx_data, cts_n, o_uart_tx, tx_busy);
always @(posedge clk) begin: SDRAM_TEST_DEBOUNCE_PB
    if ((pb_i != pb_prev)) begin
        debounce_cntr <= (49 - 1);
    end
    else begin
        if ((debounce_cntr == 0)) begin
            pb_debounced <= pb_i;
            debounce_cntr <= 1;
        end
        else begin
            debounce_cntr <= (debounce_cntr - 1);
        end
    end
    pb_prev <= pb_i;
end


always @(posedge clk) begin: SDRAM_TEST_INTERNAL_RESET
    if ((initialized == 1'b0)) begin
        initialized <= (!initialized);
    end
end


always @(sdramCntl_inst_activeRow_r[0], sdramCntl_inst_activeRow_r[1], sdramCntl_inst_activeRow_r[2], sdramCntl_inst_activeRow_r[3], sdramCntl_inst_row_s, sdramCntl_inst_sAddr_r, sdramCntl_inst_activateInProgress_s, sdramCntl_inst_activeBank_r, sdramCntl_inst_sDataDir_r, sdramCntl_inst_ba_x, sdramCntl_inst_rdPipeline_r, sdramCntl_inst_ba_r, sdramCntl_inst_rfshCntr_r, sdramCntl_inst_host_intf_wr_i, sdramCntl_inst_doActivate_s, sdramCntl_inst_bank_s, sdramCntl_inst_refTimer_r, sdramCntl_inst_rdInProgress_s, sdramCntl_inst_writeInProgress_s, sdramCntl_inst_col_s, sdramCntl_inst_state_r, sdramCntl_inst_wrTimer_r, sdramCntl_inst_timer_r, sdramCntl_inst_host_intf_rd_i, sdramCntl_inst_rasTimer_r, sdramCntl_inst_activeFlag_r[0], sdramCntl_inst_activeFlag_r[1], sdramCntl_inst_activeFlag_r[2], sdramCntl_inst_activeFlag_r[3]) begin: SDRAM_TEST_SDRAMCNTL_INST_COMB_FUNC
    integer index;
    sdramCntl_inst_rdPipeline_x = {1'b0, sdramCntl_inst_rdPipeline_r[(3 + 2)-1:1]};
    sdramCntl_inst_wrPipeline_x = 5'h0;
    if ((sdramCntl_inst_rasTimer_r != 0)) begin
        sdramCntl_inst_rasTimer_x = (sdramCntl_inst_rasTimer_r - 1);
    end
    else begin
        sdramCntl_inst_rasTimer_x = sdramCntl_inst_rasTimer_r;
    end
    if ((sdramCntl_inst_wrTimer_r != 0)) begin
        sdramCntl_inst_wrTimer_x = (sdramCntl_inst_wrTimer_r - 1);
    end
    else begin
        sdramCntl_inst_wrTimer_x = sdramCntl_inst_wrTimer_r;
    end
    if ((sdramCntl_inst_refTimer_r != 0)) begin
        sdramCntl_inst_refTimer_x = (sdramCntl_inst_refTimer_r - 1);
        sdramCntl_inst_rfshCntr_x = sdramCntl_inst_rfshCntr_r;
    end
    else begin
        sdramCntl_inst_refTimer_x = 782;
        sdramCntl_inst_rfshCntr_x = (sdramCntl_inst_rfshCntr_r + 1);
    end
    sdramCntl_inst_cmd_x = 7;
    sdramCntl_inst_state_x = sdramCntl_inst_state_r;
    sdramCntl_inst_sAddr_x = sdramCntl_inst_sAddr_r;
    sdramCntl_inst_activeBank_x = sdramCntl_inst_activeBank_r;
    sdramCntl_inst_sDataDir_x = sdramCntl_inst_sDataDir_r;
    for (index=0; index<(2 ** 2); index=index+1) begin
        sdramCntl_inst_activeFlag_x[index] = sdramCntl_inst_activeFlag_r[index];
        sdramCntl_inst_activeRow_x[index] = sdramCntl_inst_activeRow_r[index];
    end
    if ((sdramCntl_inst_timer_r != 0)) begin
        sdramCntl_inst_timer_x = (sdramCntl_inst_timer_r - 1);
        sdramCntl_inst_cmd_x = 7;
    end
    else begin
        sdramCntl_inst_timer_x = sdramCntl_inst_timer_r;
        case (sdramCntl_inst_state_r)
            3'b000: begin
                sdramCntl_inst_timer_x = 2000;
                sdramCntl_inst_state_x = 3'b001;
            end
            3'b001: begin
                sdramCntl_inst_cmd_x = 2;
                sdramCntl_inst_timer_x = 2;
                sdramCntl_inst_state_x = 3'b011;
                sdramCntl_inst_sAddr_x = 512;
                sdramCntl_inst_rfshCntr_x = 8;
            end
            3'b011: begin
                sdramCntl_inst_cmd_x = 1;
                sdramCntl_inst_timer_x = 7;
                sdramCntl_inst_rfshCntr_x = (sdramCntl_inst_rfshCntr_r - 1);
                if ((sdramCntl_inst_rfshCntr_r == 1)) begin
                    sdramCntl_inst_state_x = 3'b010;
                end
            end
            3'b010: begin
                sdramCntl_inst_cmd_x = 0;
                sdramCntl_inst_timer_x = 2;
                sdramCntl_inst_state_x = 3'b100;
                sdramCntl_inst_sAddr_x = 48;
            end
            3'b100: begin
                if ((sdramCntl_inst_rfshCntr_r != 0)) begin
                    if (((sdramCntl_inst_activateInProgress_s == 1'b0) && (sdramCntl_inst_writeInProgress_s == 1'b0) && (sdramCntl_inst_rdInProgress_s == 1'b0))) begin
                        sdramCntl_inst_cmd_x = 2;
                        sdramCntl_inst_timer_x = 2;
                        sdramCntl_inst_state_x = 3'b110;
                        sdramCntl_inst_sAddr_x = 512;
                        for (index=0; index<(2 ** 2); index=index+1) begin
                            sdramCntl_inst_activeFlag_x[index] = 1'b0;
                        end
                    end
                end
                else if ((sdramCntl_inst_host_intf_rd_i == 1'b1)) begin
                    if ((sdramCntl_inst_ba_x == sdramCntl_inst_ba_r)) begin
                        if ((sdramCntl_inst_doActivate_s == 1'b1)) begin
                            if (((sdramCntl_inst_activateInProgress_s == 1'b0) && (sdramCntl_inst_writeInProgress_s == 1'b0) && (sdramCntl_inst_rdInProgress_s == 1'b0))) begin
                                sdramCntl_inst_cmd_x = 2;
                                sdramCntl_inst_timer_x = 2;
                                sdramCntl_inst_state_x = 3'b101;
                                sdramCntl_inst_sAddr_x = 0;
                                sdramCntl_inst_activeFlag_x[sdramCntl_inst_bank_s] = 1'b0;
                            end
                        end
                        else if ((sdramCntl_inst_rdInProgress_s == 1'b0)) begin
                            sdramCntl_inst_cmd_x = 5;
                            sdramCntl_inst_sDataDir_x = 1'b0;
                            sdramCntl_inst_sAddr_x = sdramCntl_inst_col_s;
                            sdramCntl_inst_rdPipeline_x = {1'b1, sdramCntl_inst_rdPipeline_r[(3 + 2)-1:1]};
                        end
                    end
                end
                else if ((sdramCntl_inst_host_intf_wr_i == 1'b1)) begin
                    if ((sdramCntl_inst_ba_x == sdramCntl_inst_ba_r)) begin
                        if ((sdramCntl_inst_doActivate_s == 1'b1)) begin
                            if (((sdramCntl_inst_activateInProgress_s == 1'b0) && (sdramCntl_inst_writeInProgress_s == 1'b0) && (sdramCntl_inst_rdInProgress_s == 1'b0))) begin
                                sdramCntl_inst_cmd_x = 2;
                                sdramCntl_inst_timer_x = 2;
                                sdramCntl_inst_state_x = 3'b101;
                                sdramCntl_inst_sAddr_x = 0;
                                sdramCntl_inst_activeFlag_x[sdramCntl_inst_bank_s] = 1'b0;
                            end
                        end
                        else if ((sdramCntl_inst_rdInProgress_s == 1'b0)) begin
                            sdramCntl_inst_cmd_x = 4;
                            sdramCntl_inst_sDataDir_x = 1'b1;
                            sdramCntl_inst_sAddr_x = sdramCntl_inst_col_s;
                            sdramCntl_inst_wrPipeline_x = 5'h1;
                            sdramCntl_inst_wrTimer_x = 2;
                        end
                    end
                end
                else begin
                    sdramCntl_inst_cmd_x = 7;
                    sdramCntl_inst_state_x = 3'b100;
                end
            end
            3'b101: begin
                sdramCntl_inst_cmd_x = 3;
                sdramCntl_inst_timer_x = 2;
                sdramCntl_inst_state_x = 3'b100;
                sdramCntl_inst_rasTimer_x = 5;
                sdramCntl_inst_sAddr_x = sdramCntl_inst_row_s;
                sdramCntl_inst_activeBank_x = sdramCntl_inst_bank_s;
                sdramCntl_inst_activeRow_x[sdramCntl_inst_bank_s] = sdramCntl_inst_row_s;
                sdramCntl_inst_activeFlag_x[sdramCntl_inst_bank_s] = 1'b1;
            end
            3'b110: begin
                sdramCntl_inst_cmd_x = 1;
                sdramCntl_inst_timer_x = 7;
                sdramCntl_inst_state_x = 3'b100;
                sdramCntl_inst_rfshCntr_x = (sdramCntl_inst_rfshCntr_r - 1);
            end
            default: begin
                sdramCntl_inst_state_x = 3'b000;
            end
        endcase
    end
end


always @(posedge clk, posedge memory_test_inst_host_intf_rst_i) begin: SDRAM_TEST_SDRAMCNTL_INST_SEQ_FUNC
    integer index;
    if (memory_test_inst_host_intf_rst_i == 1) begin
        sdramCntl_inst_cmd_r <= 7;
        sdramCntl_inst_rdPipeline_r <= 0;
        sdramCntl_inst_sdramData_r <= 0;
        sdramCntl_inst_ba_r <= 0;
        sdramCntl_inst_wrPipeline_r <= 0;
        sdramCntl_inst_sData_r <= 0;
        sdramCntl_inst_wrTimer_r <= 0;
        sdramCntl_inst_rfshCntr_r <= 0;
        sdramCntl_inst_sAddr_r <= 0;
        sdramCntl_inst_timer_r <= 0;
        sdramCntl_inst_activeRow_r[0] <= 0;
        sdramCntl_inst_activeRow_r[1] <= 0;
        sdramCntl_inst_activeRow_r[2] <= 0;
        sdramCntl_inst_activeRow_r[3] <= 0;
        sdramCntl_inst_activeBank_r <= 0;
        sdramCntl_inst_refTimer_r <= 782;
        sdramCntl_inst_state_r <= 3'b000;
        sdramCntl_inst_rasTimer_r <= 0;
        sdramCntl_inst_sDataDir_r <= 0;
        sdramCntl_inst_activeFlag_r[0] <= 0;
        sdramCntl_inst_activeFlag_r[1] <= 0;
        sdramCntl_inst_activeFlag_r[2] <= 0;
        sdramCntl_inst_activeFlag_r[3] <= 0;
    end
    else begin
        sdramCntl_inst_state_r <= sdramCntl_inst_state_x;
        sdramCntl_inst_cmd_r <= sdramCntl_inst_cmd_x;
        sdramCntl_inst_sAddr_r <= sdramCntl_inst_sAddr_x;
		if (sdramCntl_inst_sAddr_r[15:12] > 9) begin
			message[11] <= sdramCntl_inst_sAddr_r[15:12]+(8'd55);
		end
        else
        begin
			message[11] <= sdramCntl_inst_sAddr_r[15:12]|(8'd48);
		end
		
        if (sdramCntl_inst_sdramData_r[11:8] > 9) begin
			message[12] <= sdramCntl_inst_sAddr_r[11:8]+(8'd55);
		end
        else
        begin
			message[12] <= sdramCntl_inst_sAddr_r[11:8]|(8'd48);
		end
		
        if (sdramCntl_inst_sdramData_r[7:4] > 9) begin
			message[13] <= sdramCntl_inst_sAddr_r[7:4]+(8'd55);
		end
        else
        begin
			message[13] <= sdramCntl_inst_sAddr_r[7:4]|(8'd48);
		end
		
        if (sdramCntl_inst_sAddr_r[3:0] > 9) begin
			message[14] <= sdramCntl_inst_sAddr_r[3:0]+(8'd55);
		end
        else
        begin
			message[14] <= sdramCntl_inst_sAddr_r[3:0]|(8'd48);
		end
        
        sdramCntl_inst_sData_r <= sdramCntl_inst_sData_x;
        sdramCntl_inst_sDataDir_r <= sdramCntl_inst_sDataDir_x;
        sdramCntl_inst_activeBank_r <= sdramCntl_inst_activeBank_x;
        sdramCntl_inst_sdramData_r <= sdramCntl_inst_sdramData_x;
		if (sdramCntl_inst_sdramData_r[15:12] > 9) begin
			message[20] <= sdramCntl_inst_sdramData_r[15:12]+(8'd55);
		end
        else
        begin
			message[20] <= sdramCntl_inst_sdramData_r[15:12]|(8'd48);
		end
		
        if (sdramCntl_inst_sdramData_r[11:8] > 9) begin
			message[21] <= sdramCntl_inst_sdramData_r[11:8]+(8'd55);
		end
        else
        begin
			message[21] <= sdramCntl_inst_sdramData_r[11:8]|(8'd48);
		end
		
        if (sdramCntl_inst_sdramData_r[7:4] > 9) begin
			message[22] <= sdramCntl_inst_sdramData_r[7:4]+(8'd55);
		end
        else
        begin
			message[22] <= sdramCntl_inst_sdramData_r[7:4]|(8'd48);
		end
		
        if (sdramCntl_inst_sdramData_r[3:0] > 9) begin
			message[23] <= sdramCntl_inst_sdramData_r[3:0]+(8'd55);
		end
        else
        begin
			message[23] <= sdramCntl_inst_sdramData_r[3:0]|(8'd48);
		end
        sdramCntl_inst_wrPipeline_r <= sdramCntl_inst_wrPipeline_x;
        sdramCntl_inst_rdPipeline_r <= sdramCntl_inst_rdPipeline_x;
        sdramCntl_inst_ba_r <= sdramCntl_inst_ba_x;
        sdramCntl_inst_timer_r <= sdramCntl_inst_timer_x;
        sdramCntl_inst_rasTimer_r <= sdramCntl_inst_rasTimer_x;
        sdramCntl_inst_refTimer_r <= sdramCntl_inst_refTimer_x;
        sdramCntl_inst_wrTimer_r <= sdramCntl_inst_wrTimer_x;
        sdramCntl_inst_rfshCntr_r <= sdramCntl_inst_rfshCntr_x;
        for (index=0; index<(2 ** 2); index=index+1) begin
            sdramCntl_inst_activeRow_r[index] <= sdramCntl_inst_activeRow_x[index];
            sdramCntl_inst_activeFlag_r[index] <= sdramCntl_inst_activeFlag_x[index];
        end
    end
end


always @(sdramCntl_inst_cmd_r, sdramCntl_inst_sData_r, sdramCntl_inst_sAddr_r, sdramCntl_inst_bank_s, sdramCntl_inst_sDataDir_r) begin: SDRAM_TEST_SDRAMCNTL_INST_SDRAM_PIN_MAP
    sdramCntl_inst_sd_intf_cke = 1;
    sdramCntl_inst_sd_intf_cs = 0;
    sdramCntl_inst_sd_intf_ras = sdramCntl_inst_cmd_r[2];
    sdramCntl_inst_sd_intf_cas = sdramCntl_inst_cmd_r[1];
    sdramCntl_inst_sd_intf_we = sdramCntl_inst_cmd_r[0];
    sdramCntl_inst_sd_intf_bs = sdramCntl_inst_bank_s;
    sdramCntl_inst_sd_intf_addr = sdramCntl_inst_sAddr_r;
    if ((sdramCntl_inst_sDataDir_r == 1'b1)) begin
        sdramCntl_inst_sDriver = sdramCntl_inst_sData_r;
    end
    else begin
        sdramCntl_inst_sDriver = 'bz;
    end
    sdramCntl_inst_sd_intf_dqml = 0;
    sdramCntl_inst_sd_intf_dqmh = 0;
end



assign sdramCntl_inst_host_intf_done_o = (sdramCntl_inst_rdPipeline_r[0] || sdramCntl_inst_wrPipeline_r[0]);
assign sdramCntl_inst_host_intf_data_o = sdramCntl_inst_sdramData_r;
assign sdramCntl_inst_host_intf_rdPending_o = sdramCntl_inst_rdInProgress_s;
assign sdramCntl_inst_sData_x = sdramCntl_inst_host_intf_data_i;



assign sdramCntl_inst_bank_s = sdramCntl_inst_host_intf_addr_i[((2 + 13) + 9)-1:(13 + 9)];
assign sdramCntl_inst_ba_x = sdramCntl_inst_host_intf_addr_i[((2 + 13) + 9)-1:(13 + 9)];
assign sdramCntl_inst_row_s = sdramCntl_inst_host_intf_addr_i[(13 + 9)-1:9];
assign sdramCntl_inst_col_s = sdramCntl_inst_host_intf_addr_i[9-1:0];


always @(sdramCntl_inst_activeRow_r[0], sdramCntl_inst_activeRow_r[1], sdramCntl_inst_activeRow_r[2], sdramCntl_inst_activeRow_r[3], sdramCntl_inst_rdPipeline_r, sdramCntl_inst_bank_s, sdramCntl_inst_sdramData_r, sdramCntl_inst_activeBank_r, sdramCntl_inst_wrTimer_r, sdramCntl_inst_sd_intf_dq, sdramCntl_inst_row_s, sdramCntl_inst_rasTimer_r, sdramCntl_inst_activeFlag_r[0], sdramCntl_inst_activeFlag_r[1], sdramCntl_inst_activeFlag_r[2], sdramCntl_inst_activeFlag_r[3]) begin: SDRAM_TEST_SDRAMCNTL_INST_DO_ACTIVE
    if (((sdramCntl_inst_bank_s != sdramCntl_inst_activeBank_r) || (sdramCntl_inst_row_s != sdramCntl_inst_activeRow_r[sdramCntl_inst_bank_s]) || (sdramCntl_inst_activeFlag_r[sdramCntl_inst_bank_s] == 1'b0))) begin
        sdramCntl_inst_doActivate_s = 1'b1;
    end
    else begin
        sdramCntl_inst_doActivate_s = 1'b0;
    end
    if ((sdramCntl_inst_rdPipeline_r[1] == 1'b1)) begin
        sdramCntl_inst_sdramData_x = sdramCntl_inst_sd_intf_dq;
    end
    else begin
        sdramCntl_inst_sdramData_x = sdramCntl_inst_sdramData_r;
    end
    if ((sdramCntl_inst_rasTimer_r != 0)) begin
        sdramCntl_inst_activateInProgress_s = 1'b1;
    end
    else begin
        sdramCntl_inst_activateInProgress_s = 1'b0;
    end
    if ((sdramCntl_inst_wrTimer_r != 0)) begin
        sdramCntl_inst_writeInProgress_s = 1'b1;
    end
    else begin
        sdramCntl_inst_writeInProgress_s = 1'b0;
    end
    if ((sdramCntl_inst_rdPipeline_r[(3 + 2)-1:1] != 0)) begin
        sdramCntl_inst_rdInProgress_s = 1'b1;
    end
    else begin
        sdramCntl_inst_rdInProgress_s = 1'b0;
    end
end


always @(led_disp_inst_digit_shf, led_disp_inst_active_segments, led_disp_inst_blank) begin: SDRAM_TEST_LED_DISP_INST_COMBINE_DRIVERS
    if ((led_disp_inst_blank == 1'b1)) begin
        led_disp_inst_drvr_enbls = 0;
    end
    else if ((led_disp_inst_digit_shf[0] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:1] = led_disp_inst_active_segments[7-1:0];
        led_disp_inst_drvr_enbls[0] = 1;
    end
    else if ((led_disp_inst_digit_shf[1] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:2] = led_disp_inst_active_segments[7-1:1];
        led_disp_inst_drvr_enbls[1] = 1;
        led_disp_inst_drvr_enbls[0] = led_disp_inst_active_segments[1-1:0];
    end
    else if ((led_disp_inst_digit_shf[2] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:3] = led_disp_inst_active_segments[7-1:2];
        led_disp_inst_drvr_enbls[2] = 1;
        led_disp_inst_drvr_enbls[2-1:0] = led_disp_inst_active_segments[2-1:0];
    end
    else if ((led_disp_inst_digit_shf[3] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:4] = led_disp_inst_active_segments[7-1:3];
        led_disp_inst_drvr_enbls[3] = 1;
        led_disp_inst_drvr_enbls[3-1:0] = led_disp_inst_active_segments[3-1:0];
    end
    else if ((led_disp_inst_digit_shf[4] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:5] = led_disp_inst_active_segments[7-1:4];
        led_disp_inst_drvr_enbls[4] = 1;
        led_disp_inst_drvr_enbls[4-1:0] = led_disp_inst_active_segments[4-1:0];
    end
    else if ((led_disp_inst_digit_shf[5] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:6] = led_disp_inst_active_segments[7-1:5];
        led_disp_inst_drvr_enbls[5] = 1;
        led_disp_inst_drvr_enbls[5-1:0] = led_disp_inst_active_segments[5-1:0];
    end
    else if ((led_disp_inst_digit_shf[6] == 1)) begin
        led_disp_inst_drvr_enbls[8-1:7] = led_disp_inst_active_segments[7-1:6];
        led_disp_inst_drvr_enbls[6] = 1;
        led_disp_inst_drvr_enbls[6-1:0] = led_disp_inst_active_segments[6-1:0];
    end
    else if ((led_disp_inst_digit_shf[7] == 1)) begin
        led_disp_inst_drvr_enbls[7] = 1;
        led_disp_inst_drvr_enbls[7-1:0] = led_disp_inst_active_segments[7-1:0];
    end
    else begin
        led_disp_inst_drvr_enbls = 0;
    end
end



assign led_disp_inst_active_segments = (led_disp_inst_segments & led_disp_inst_seg_mask);


always @(test_status, led_disp_inst_digit_shf, led_disp_inst_digit_all_i) begin: SDRAM_TEST_LED_DISP_INST_GET_ACTIVE_DIGIT
    if ((led_disp_inst_digit_shf[0] == 1)) begin
        led_disp_inst_active_digit = (test_status | led_disp_inst_digit_all_i[7-1:0]);
    end
    else if ((led_disp_inst_digit_shf[1] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[14-1:7]);
    end
    else if ((led_disp_inst_digit_shf[2] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[21-1:14]);
    end
    else if ((led_disp_inst_digit_shf[3] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[28-1:21]);
    end
    else if ((led_disp_inst_digit_shf[4] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[35-1:28]);
    end
    else if ((led_disp_inst_digit_shf[5] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[42-1:35]);
    end
    else if ((led_disp_inst_digit_shf[6] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[49-1:42]);
    end
    else if ((led_disp_inst_digit_shf[7] == 1)) begin
        led_disp_inst_active_digit = (32 | led_disp_inst_digit_all_i[56-1:49]);
    end
    else begin
        led_disp_inst_active_digit = 0;
    end
end


always @(led_disp_inst_active_digit) begin: SDRAM_TEST_LED_DISP_INST_INST_0_LOGIC
    if ((led_disp_inst_active_digit == 32)) begin
        led_disp_inst_segments = 7'b0000000;
    end
    else if ((led_disp_inst_active_digit == 45)) begin
        led_disp_inst_segments = 7'b1000000;
    end
    else if (((led_disp_inst_active_digit == 0) || (led_disp_inst_active_digit == 48))) begin
        led_disp_inst_segments = 7'b0111111;
    end
    else if (((led_disp_inst_active_digit == 1) || (led_disp_inst_active_digit == 49))) begin
        led_disp_inst_segments = 7'b0000110;
    end
    else if (((led_disp_inst_active_digit == 2) || (led_disp_inst_active_digit == 50))) begin
        led_disp_inst_segments = 7'b1011011;
    end
    else if (((led_disp_inst_active_digit == 3) || (led_disp_inst_active_digit == 51))) begin
        led_disp_inst_segments = 7'b1001111;
    end
    else if (((led_disp_inst_active_digit == 4) || (led_disp_inst_active_digit == 52))) begin
        led_disp_inst_segments = 7'b1100110;
    end
    else if (((led_disp_inst_active_digit == 5) || (led_disp_inst_active_digit == 53))) begin
        led_disp_inst_segments = 7'b1101101;
    end
    else if (((led_disp_inst_active_digit == 6) || (led_disp_inst_active_digit == 54))) begin
        led_disp_inst_segments = 7'b1111101;
    end
    else if (((led_disp_inst_active_digit == 7) || (led_disp_inst_active_digit == 55))) begin
        led_disp_inst_segments = 7'b0000111;
    end
    else if (((led_disp_inst_active_digit == 8) || (led_disp_inst_active_digit == 56))) begin
        led_disp_inst_segments = 7'b1111111;
    end
    else if (((led_disp_inst_active_digit == 9) || (led_disp_inst_active_digit == 57))) begin
        led_disp_inst_segments = 7'b1101111;
    end
    else if (((led_disp_inst_active_digit == 10) || (led_disp_inst_active_digit == 65) || (led_disp_inst_active_digit == 97))) begin
        led_disp_inst_segments = 7'b1110111;
    end
    else if (((led_disp_inst_active_digit == 11) || (led_disp_inst_active_digit == 66) || (led_disp_inst_active_digit == 98))) begin
        led_disp_inst_segments = 7'b1111100;
    end
    else if (((led_disp_inst_active_digit == 12) || (led_disp_inst_active_digit == 67) || (led_disp_inst_active_digit == 99))) begin
        led_disp_inst_segments = 7'b0111001;
    end
    else if (((led_disp_inst_active_digit == 13) || (led_disp_inst_active_digit == 68) || (led_disp_inst_active_digit == 100))) begin
        led_disp_inst_segments = 7'b1011110;
    end
    else if (((led_disp_inst_active_digit == 14) || (led_disp_inst_active_digit == 69) || (led_disp_inst_active_digit == 101))) begin
        led_disp_inst_segments = 7'b1111001;
    end
    else if (((led_disp_inst_active_digit == 15) || (led_disp_inst_active_digit == 70) || (led_disp_inst_active_digit == 102))) begin
        led_disp_inst_segments = 7'b1110001;
    end
    else if (((led_disp_inst_active_digit == 71) || (led_disp_inst_active_digit == 103))) begin
        led_disp_inst_segments = 7'b0111101;
    end
    else if (((led_disp_inst_active_digit == 72) || (led_disp_inst_active_digit == 104))) begin
        led_disp_inst_segments = 7'b1110100;
    end
    else if (((led_disp_inst_active_digit == 73) || (led_disp_inst_active_digit == 105))) begin
        led_disp_inst_segments = 7'b0110000;
    end
    else if (((led_disp_inst_active_digit == 74) || (led_disp_inst_active_digit == 106))) begin
        led_disp_inst_segments = 7'b0011110;
    end
    else if (((led_disp_inst_active_digit == 75) || (led_disp_inst_active_digit == 107))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 76) || (led_disp_inst_active_digit == 108))) begin
        led_disp_inst_segments = 7'b0111000;
    end
    else if (((led_disp_inst_active_digit == 77) || (led_disp_inst_active_digit == 109))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 78) || (led_disp_inst_active_digit == 110))) begin
        led_disp_inst_segments = 7'b1010100;
    end
    else if (((led_disp_inst_active_digit == 79) || (led_disp_inst_active_digit == 111))) begin
        led_disp_inst_segments = 7'b1011100;
    end
    else if (((led_disp_inst_active_digit == 80) || (led_disp_inst_active_digit == 112))) begin
        led_disp_inst_segments = 7'b1110011;
    end
    else if (((led_disp_inst_active_digit == 81) || (led_disp_inst_active_digit == 113))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 82) || (led_disp_inst_active_digit == 114))) begin
        led_disp_inst_segments = 7'b1010000;
    end
    else if (((led_disp_inst_active_digit == 83) || (led_disp_inst_active_digit == 115))) begin
        led_disp_inst_segments = 7'b1101101;
    end
    else if (((led_disp_inst_active_digit == 84) || (led_disp_inst_active_digit == 116))) begin
        led_disp_inst_segments = 7'b1111000;
    end
    else if (((led_disp_inst_active_digit == 85) || (led_disp_inst_active_digit == 117))) begin
        led_disp_inst_segments = 7'b0011100;
    end
    else if (((led_disp_inst_active_digit == 86) || (led_disp_inst_active_digit == 118))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 87) || (led_disp_inst_active_digit == 119))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 88) || (led_disp_inst_active_digit == 120))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if (((led_disp_inst_active_digit == 89) || (led_disp_inst_active_digit == 121))) begin
        led_disp_inst_segments = 7'b1101110;
    end
    else if (((led_disp_inst_active_digit == 90) || (led_disp_inst_active_digit == 122))) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else if ((led_disp_inst_active_digit == 95)) begin
        led_disp_inst_segments = 7'b0001000;
    end
    else begin
        led_disp_inst_segments = 7'b0001000;
    end
end



assign led_disp_inst_inst_1_dummy = (led_disp_drvrs[0] != 0);


always @(led_disp_inst_digit_shf[0], led_disp_inst_drvr_enbls[0]) begin: SDRAM_TEST_LED_DISP_INST_INST_1_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[0] == 1)) begin
        led_disp_inst_inst_1_o_drvr = led_disp_inst_digit_shf[0];
    end
    else begin
        led_disp_inst_inst_1_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_2_dummy = (led_disp_drvrs[1] != 0);


always @(led_disp_inst_digit_shf[1], led_disp_inst_drvr_enbls[1]) begin: SDRAM_TEST_LED_DISP_INST_INST_2_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[1] == 1)) begin
        led_disp_inst_inst_2_o_drvr = led_disp_inst_digit_shf[1];
    end
    else begin
        led_disp_inst_inst_2_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_3_dummy = (led_disp_drvrs[2] != 0);


always @(led_disp_inst_digit_shf[2], led_disp_inst_drvr_enbls[2]) begin: SDRAM_TEST_LED_DISP_INST_INST_3_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[2] == 1)) begin
        led_disp_inst_inst_3_o_drvr = led_disp_inst_digit_shf[2];
    end
    else begin
        led_disp_inst_inst_3_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_4_dummy = (led_disp_drvrs[3] != 0);


always @(led_disp_inst_digit_shf[3], led_disp_inst_drvr_enbls[3]) begin: SDRAM_TEST_LED_DISP_INST_INST_4_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[3] == 1)) begin
        led_disp_inst_inst_4_o_drvr = led_disp_inst_digit_shf[3];
    end
    else begin
        led_disp_inst_inst_4_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_5_dummy = (led_disp_drvrs[4] != 0);


always @(led_disp_inst_digit_shf[4], led_disp_inst_drvr_enbls[4]) begin: SDRAM_TEST_LED_DISP_INST_INST_5_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[4] == 1)) begin
        led_disp_inst_inst_5_o_drvr = led_disp_inst_digit_shf[4];
    end
    else begin
        led_disp_inst_inst_5_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_6_dummy = (led_disp_drvrs[5] != 0);


always @(led_disp_inst_digit_shf[5], led_disp_inst_drvr_enbls[5]) begin: SDRAM_TEST_LED_DISP_INST_INST_6_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[5] == 1)) begin
        led_disp_inst_inst_6_o_drvr = led_disp_inst_digit_shf[5];
    end
    else begin
        led_disp_inst_inst_6_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_7_dummy = (led_disp_drvrs[6] != 0);


always @(led_disp_inst_digit_shf[6], led_disp_inst_drvr_enbls[6]) begin: SDRAM_TEST_LED_DISP_INST_INST_7_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[6] == 1)) begin
        led_disp_inst_inst_7_o_drvr = led_disp_inst_digit_shf[6];
    end
    else begin
        led_disp_inst_inst_7_o_drvr = 'bz;
    end
end



assign led_disp_inst_inst_8_dummy = (led_disp_drvrs[7] != 0);


always @(led_disp_inst_digit_shf[7], led_disp_inst_drvr_enbls[7]) begin: SDRAM_TEST_LED_DISP_INST_INST_8_DRVR_LOGIC
    if ((led_disp_inst_drvr_enbls[7] == 1)) begin
        led_disp_inst_inst_8_o_drvr = led_disp_inst_digit_shf[7];
    end
    else begin
        led_disp_inst_inst_8_o_drvr = 'bz;
    end
end


always @(posedge clk) begin: SDRAM_TEST_LED_DISP_INST_SCAN_SEGMENTS_AND_DIGITS
    if ((led_disp_inst_initialized != 1'b1)) begin
        led_disp_inst_seg_mask <= 7'b0010101;
        led_disp_inst_digit_shf <= 8'b00000001;
        led_disp_inst_initialized <= (!led_disp_inst_initialized);
    end
    else if ((led_disp_inst_seg_timer == 0)) begin
        led_disp_inst_seg_timer <= (597 - 1);
        led_disp_inst_seg_mask[7-1:1] <= led_disp_inst_seg_mask[6-1:0];
        led_disp_inst_seg_mask[0] <= led_disp_inst_seg_mask[6];
        led_disp_inst_blank <= (led_disp_inst_seg_cntr == 1);
        if ((led_disp_inst_seg_cntr == 0)) begin
            led_disp_inst_digit_shf[8-1:1] <= led_disp_inst_digit_shf[7-1:0];
            led_disp_inst_digit_shf[0] <= led_disp_inst_digit_shf[7];
            led_disp_inst_seg_cntr <= (7 - 1);
        end
        else begin
            led_disp_inst_seg_cntr <= (led_disp_inst_seg_cntr - 1);
        end
    end
    else begin
        led_disp_inst_seg_timer <= (led_disp_inst_seg_timer - 1);
    end
end



assign led_disp_d0_o = led_disp_drvrs[0];
assign led_disp_d1_o = led_disp_drvrs[1];
assign led_disp_d2_o = led_disp_drvrs[2];
assign led_disp_d3_o = led_disp_drvrs[3];
assign led_disp_d4_o = led_disp_drvrs[4];
assign led_disp_d5_o = led_disp_drvrs[5];
assign led_disp_d6_o = led_disp_drvrs[6];
assign led_disp_d7_o = led_disp_drvrs[7];



assign memory_test_inst_rand_val = memory_test_inst_rand_gen_shfreg;


always @(posedge clk) begin: SDRAM_TEST_MEMORY_TEST_INST_RAND_GEN_RAND_SHIFT
    integer i;
    integer xor_bit;
    integer bits;
    bits = (memory_test_inst_rand_gen_shfreg & 53256);
    xor_bit = 0;
    for (i=0; i<16; i=i+1) begin
        xor_bit = (xor_bit ^ bits[i]);
    end
    if (memory_test_inst_rand_load) begin
        memory_test_inst_rand_gen_shfreg <= 42;
    end
    else if (memory_test_inst_rand_enable) begin
        memory_test_inst_rand_gen_shfreg[16-1:1] <= memory_test_inst_rand_gen_shfreg[(16 - 1)-1:0];
        memory_test_inst_rand_gen_shfreg[0] <= xor_bit;
    end
end


always @(posedge clk) begin: SDRAM_TEST_MEMORY_TEST_INST_SDRAM_TESTER
    if ((reset == 1'b1)) begin
        memory_test_inst_error <= 1'b0;
        memory_test_inst_test_state <= 2'b01;
        test_status <= 49;
        message[5] <= test_status;
        led_status <= 4'h1;
        memory_test_inst_address <= 0;
        memory_test_inst_rand_load <= 1;
    end
    else if ((memory_test_inst_test_state == 2'b01)) begin
        memory_test_inst_rand_load <= 0;
        memory_test_inst_rand_enable <= 0;
        test_status <= 50;
        message[5] <= test_status;
        led_status <= 4'h2;
        if ((sdramCntl_inst_host_intf_done_o == 1'b0)) begin
            memory_test_inst_wr_enable <= 1'b1;
        end
        else begin
            memory_test_inst_wr_enable <= 1'b0;
            memory_test_inst_rand_enable <= 1;
            memory_test_inst_address <= (memory_test_inst_address + 1);
            if ((memory_test_inst_address == 16777215)) begin
                memory_test_inst_test_state <= 2'b10;
                memory_test_inst_address <= 0;
                memory_test_inst_rand_load <= 1;
                memory_test_inst_error <= 1'b0;
            end
        end
    end
    else if ((memory_test_inst_test_state == 2'b10)) begin
        memory_test_inst_rand_load <= 0;
        memory_test_inst_rand_enable <= 0;
        test_status <= 51;
        message[5] <= test_status;
        led_status <= 4'h4;
        if ((sdramCntl_inst_host_intf_done_o == 1'b0)) begin
            memory_test_inst_rd_enable <= 1'b1;
        end
        else begin
            memory_test_inst_rd_enable <= 1'b0;
            memory_test_inst_rand_enable <= 1;
            memory_test_inst_address <= (memory_test_inst_address + 1);
            if ((memory_test_inst_rand_val != sdramCntl_inst_host_intf_data_o)) begin
                memory_test_inst_error <= 1'b1;
            end
            if ((memory_test_inst_address == 16777215)) begin
                memory_test_inst_test_state <= 2'b11;
            end
        end
    end
    else begin
        memory_test_inst_rand_load <= 0;
        memory_test_inst_rand_enable <= 0;
        if ((memory_test_inst_error == 1'b1)) begin
            test_status <= 70;
            message[5] <= test_status;
            led_status <= 4'h8;
        end
        else begin
            test_status <= 79;
            led_status <= 4'hf;
        end
    end
end



assign memory_test_inst_host_intf_rst_i = reset;
assign sdramCntl_inst_host_intf_wr_i = (memory_test_inst_wr_enable && (!sdramCntl_inst_host_intf_done_o));
assign sdramCntl_inst_host_intf_rd_i = (memory_test_inst_rd_enable && (!sdramCntl_inst_host_intf_done_o));
assign sdramCntl_inst_host_intf_data_i = memory_test_inst_rand_val;
assign sdramCntl_inst_host_intf_addr_i = memory_test_inst_address;

endmodule
`define	TXU_BIT_ZERO	4'h0
`define	TXU_BIT_ONE	4'h1
`define	TXU_BIT_TWO	4'h2
`define	TXU_BIT_THREE	4'h3
`define	TXU_BIT_FOUR	4'h4
`define	TXU_BIT_FIVE	4'h5
`define	TXU_BIT_SIX	4'h6
`define	TXU_BIT_SEVEN	4'h7
`define	TXU_PARITY	4'h8	// Constant 1
`define	TXU_STOP	4'h9	// Constant 1
`define	TXU_SECOND_STOP	4'ha

`define	TXU_BREAK	4'he
`define	TXU_IDLE	4'hf
module txuart(i_clk, i_reset, i_setup, i_break, i_wr, i_data,
		i_cts_n, o_uart_tx, o_busy);
	parameter	[30:0]	INITIAL_SETUP = 31'd868;
	input	wire		i_clk, i_reset;
	input	wire	[30:0]	i_setup;
	input	wire		i_break;
	input	wire		i_wr;
	input	wire	[7:0]	i_data;
	// Hardware flow control Ready-To-Send bit.  Set this to one to use
	// the core without flow control.  (A more appropriate name would be
	// the Ready-To-Receive bit ...)
	input	wire		i_cts_n;
	// And the UART input line itself
	output	reg		o_uart_tx;
	// A line to tell others when we are ready to accept data.  If
	// (i_wr)&&(!o_busy) is ever true, then the core has accepted a byte
	// for transmission.
	output	wire		o_busy;

	wire	[27:0]	clocks_per_baud, break_condition;
	wire	[1:0]	data_bits;
	wire		use_parity, parity_even, dblstop, fixd_parity,
			fixdp_value, hw_flow_control;
	reg	[30:0]	r_setup;
	assign	clocks_per_baud = { 4'h0, r_setup[23:0] };
	assign	break_condition = { r_setup[23:0], 4'h0 };
	assign	hw_flow_control = !r_setup[30];
	assign	data_bits       =  r_setup[29:28];
	assign	dblstop         =  r_setup[27];
	assign	use_parity      =  r_setup[26];
	assign	fixd_parity     =  r_setup[25];
	assign	parity_even     =  r_setup[24];
	assign	fixdp_value     =  r_setup[24];

	reg	[27:0]	baud_counter;
	reg	[3:0]	state;
	reg	[7:0]	lcl_data;
	reg		calc_parity, r_busy, zero_baud_counter;


	// First step ... handle any hardware flow control, if so enabled.
	//
	// Clock in the flow control data, two clocks to avoid metastability
	// Default to using hardware flow control (uart_setup[30]==0 to use it).
	// Set this high order bit off if you do not wish to use it.
	reg	q_cts_n, qq_cts_n, ck_cts;
	// While we might wish to give initial values to q_rts and ck_cts,
	// 1) it's not required since the transmitter starts in a long wait
	// state, and 2) doing so will prevent the synthesizer from optimizing
	// this pin in the case it is hard set to 1'b1 external to this
	// peripheral.
	//
	// initial	q_cts_n  = 1'b1;
	// initial	qq_cts_n = 1'b1;
	// initial	ck_cts   = 1'b0;
	always	@(posedge i_clk)
		q_cts_n <= i_cts_n;
	always	@(posedge i_clk)
		qq_cts_n <= q_cts_n;
	always	@(posedge i_clk)
		ck_cts <= (!qq_cts_n)||(!hw_flow_control);

	initial	o_uart_tx = 1'b1;
	initial	r_busy = 1'b1;
	initial	state  = `TXU_IDLE;
	initial	lcl_data= 8'h0;
	initial	calc_parity = 1'b0;
	// initial	baud_counter = clocks_per_baud;//ILLEGAL--not constant
	always @(posedge i_clk)
	begin
		if (i_reset)
		begin
			r_busy <= 1'b1;
			state <= `TXU_IDLE;
		end else if (i_break)
		begin
			state <= `TXU_BREAK;
			r_busy <= 1'b1;
		end else if (!zero_baud_counter)
		begin // r_busy needs to be set coming into here
			r_busy <= 1'b1;
		end else if (state == `TXU_BREAK)
		begin
			state <= `TXU_IDLE;
			r_busy <= 1'b1;
		end else if (state == `TXU_IDLE)	// STATE_IDLE
		begin
			if ((i_wr)&&(!r_busy))
			begin	// Immediately start us off with a start bit
				r_busy <= 1'b1;
				case(data_bits)
				2'b00: state <= `TXU_BIT_ZERO;
				2'b01: state <= `TXU_BIT_ONE;
				2'b10: state <= `TXU_BIT_TWO;
				2'b11: state <= `TXU_BIT_THREE;
				endcase
			end else begin // Stay in idle
				r_busy <= !ck_cts;
			end
		end else begin
			// One clock tick in each of these states ...
			// baud_counter <= clocks_per_baud - 28'h01;
			r_busy <= 1'b1;
			if (state[3] == 0) // First 8 bits
			begin
				if (state == `TXU_BIT_SEVEN)
					state <= (use_parity)?`TXU_PARITY:`TXU_STOP;
				else
					state <= state + 1;
			end else if (state == `TXU_PARITY)
			begin
				state <= `TXU_STOP;
			end else if (state == `TXU_STOP)
			begin // two stop bit(s)
				if (dblstop)
					state <= `TXU_SECOND_STOP;
				else
					state <= `TXU_IDLE;
			end else // `TXU_SECOND_STOP and default:
			begin
				state <= `TXU_IDLE; // Go back to idle
				// Still r_busy, since we need to wait
				// for the baud clock to finish counting
				// out this last bit.
			end
		end 
	end

	// o_busy
	//
	// This is a wire, designed to be true is we are ever busy above.
	// originally, this was going to be true if we were ever not in the
	// idle state.  The logic has since become more complex, hence we have
	// a register dedicated to this and just copy out that registers value.
	assign	o_busy = (r_busy);


	// r_setup
	//
	// Our setup register.  Accept changes between any pair of transmitted
	// words.  The register itself has many fields to it.  These are
	// broken out up top, and indicate what 1) our baud rate is, 2) our
	// number of stop bits, 3) what type of parity we are using, and 4)
	// the size of our data word.
	initial	r_setup = INITIAL_SETUP;
	always @(posedge i_clk)
		if (state == `TXU_IDLE)
			r_setup <= i_setup;

	// lcl_data
	//
	// This is our working copy of the i_data register which we use
	// when transmitting.  It is only of interest during transmit, and is
	// allowed to be whatever at any other time.  Hence, if r_busy isn't
	// true, we can always set it.  On the one clock where r_busy isn't
	// true and i_wr is, we set it and r_busy is true thereafter.
	// Then, on any zero_baud_counter (i.e. change between baud intervals)
	// we simple logically shift the register right to grab the next bit.
	always @(posedge i_clk)
		if (!r_busy)
			lcl_data <= i_data;
		else if (zero_baud_counter)
			lcl_data <= { 1'b0, lcl_data[7:1] };

	// o_uart_tx
	//
	// This is the final result/output desired of this core.  It's all
	// centered about o_uart_tx.  This is what finally needs to follow
	// the UART protocol.
	//
	// Ok, that said, our rules are:
	//	1'b0 on any break condition
	//	1'b0 on a start bit (IDLE, write, and not busy)
	//	lcl_data[0] during any data transfer, but only at the baud
	//		change
	//	PARITY -- During the parity bit.  This depends upon whether or
	//		not the parity bit is fixed, then what it's fixed to,
	//		or changing, and hence what it's calculated value is.
	//	1'b1 at all other times (stop bits, idle, etc)
	always @(posedge i_clk)
		if (i_reset)
			o_uart_tx <= 1'b1;
		else if ((i_break)||((i_wr)&&(!r_busy)))
			o_uart_tx <= 1'b0;
		else if (zero_baud_counter)
			casez(state)
			4'b0???:	o_uart_tx <= lcl_data[0];
			`TXU_PARITY:	o_uart_tx <= calc_parity;
			default:	o_uart_tx <= 1'b1;
			endcase


	// calc_parity
	//
	// Calculate the parity to be placed into the parity bit.  If the
	// parity is fixed, then the parity bit is given by the fixed parity
	// value (r_setup[24]).  Otherwise the parity is given by the GF2
	// sum of all the data bits (plus one for even parity).
	always @(posedge i_clk)
		if (fixd_parity)
			calc_parity <= fixdp_value;
		else if (zero_baud_counter)
		begin
			if (state[3] == 0) // First 8 bits of msg
				calc_parity <= calc_parity ^ lcl_data[0];
			else
				calc_parity <= parity_even;
		end else if (!r_busy)
			calc_parity <= parity_even;


	// All of the above logic is driven by the baud counter.  Bits must last
	// clocks_per_baud in length, and this baud counter is what we use to
	// make certain of that.
	//
	// The basic logic is this: at the beginning of a bit interval, start
	// the baud counter and set it to count clocks_per_baud.  When it gets
	// to zero, restart it.
	//
	// However, comparing a 28'bit number to zero can be rather complex--
	// especially if we wish to do anything else on that same clock.  For
	// that reason, we create "zero_baud_counter".  zero_baud_counter is
	// nothing more than a flag that is true anytime baud_counter is zero.
	// It's true when the logic (above) needs to step to the next bit.
	// Simple enough?
	//
	// I wish we could stop there, but there are some other (ugly)
	// conditions to deal with that offer exceptions to this basic logic.
	//
	// 1. When the user has commanded a BREAK across the line, we need to
	// wait several baud intervals following the break before we start
	// transmitting, to give any receiver a chance to recognize that we are
	// out of the break condition, and to know that the next bit will be
	// a stop bit.
	//
	// 2. A reset is similar to a break condition--on both we wait several
	// baud intervals before allowing a start bit.
	//
	// 3. In the idle state, we stop our counter--so that upon a request
	// to transmit when idle we can start transmitting immediately, rather
	// than waiting for the end of the next (fictitious and arbitrary) baud
	// interval.
	//
	// When (i_wr)&&(!r_busy)&&(state == `TXU_IDLE) then we're not only in
	// the idle state, but we also just accepted a command to start writing
	// the next word.  At this point, the baud counter needs to be reset
	// to the number of clocks per baud, and zero_baud_counter set to zero.
	//
	// The logic is a bit twisted here, in that it will only check for the
	// above condition when zero_baud_counter is false--so as to make
	// certain the STOP bit is complete.
	initial	zero_baud_counter = 1'b0;
	initial	baud_counter = 28'h05;
	always @(posedge i_clk)
	begin
		zero_baud_counter <= (baud_counter == 28'h01);
		if ((i_reset)||(i_break))
		begin
			// Give ourselves 16 bauds before being ready
			baud_counter <= break_condition;
			zero_baud_counter <= 1'b0;
		end else if (!zero_baud_counter)
			baud_counter <= baud_counter - 28'h01;
		else if (state == `TXU_BREAK)
			// Give us four idle baud intervals before becoming
			// available
			baud_counter <= clocks_per_baud<<2;
		else if (state == `TXU_IDLE)
		begin
			baud_counter <= 28'h0;
			zero_baud_counter <= 1'b1;
			if ((i_wr)&&(!r_busy))
			begin
				baud_counter <= clocks_per_baud - 28'h01;
				zero_baud_counter <= 1'b0;
			end
		end else
			baud_counter <= clocks_per_baud - 28'h01;
	end
endmodule 

